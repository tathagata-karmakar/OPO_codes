#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Jul 31 09:22:51 2023

@author: t_karmakar
"""

import os
import qutip as qt
import time
import matplotlib.pyplot as plt
import matplotlib as mpl
import numpy as np
from scipy.integrate import simps as intg
from matplotlib import rc
from pylab import rcParams
from FNO_structure import *
os.environ["PATH"] += os.pathsep + '/Library/TeX/texbin'
rc('text',usetex=True)

import jax
import jax.numpy as jnp
from jax import grad, jit, vmap
from jax import random
from jax import lax
from jax import device_put
from jax import make_jaxpr
from functools import partial
import collections 
from typing import Iterable

def init_mlp_params(layer_widths):
    params = []
    for n_in,n_out in zip(layer_widths[:-1],layer_widths[1:]):
        params.append(dict(weights=np.random.normal(size=(n_in,n_out))*np.sqrt(2/n_in),biases=np.ones(shape=(n_out,))))
    return params

def forward(params,x):
    *hidden,last=params
    for layer in hidden:
        x=jax.nn.relu(x @ layer['weights']+layer['biases'])
    return x @ last['weights']+last['biases']

def loss_fn(params,x,y):
    return jnp.mean((forward(params,x)-y)**2)

lrate=0.0001

@jit
def update(params, x,y):
    grads=jax.grad(loss_fn)(params,x,y)
    return jax.tree_map(lambda p,g:p-lrate*g,params, grads)


ATuple = collections.namedtuple("ATuple",('name'))

tree=[1,{'k1':2,'k2':(3,4)},ATuple('foo')]
flattened,_=jax.tree_util.tree_flatten_with_path(tree)
for key_path, value in flattened:
    print(f'Value of tree{jax.tree_util.keystr(key_path)}: {value}')
    
class MyContainer:
    
    def __init__(self,name: str, a: int, b: int, c:int):
        self.name=name
        self.a=a
        self.b=b
        self.c=c

#tt=jax.tree_util.tree_leaves([MyContainer('Alice', 1 ,2, 3), MyContainer('Bob', 4 ,5, 6)])


def flatten_MyContainer(container) -> tuple[Iterable[int],str]:
    flat_contents = [container.a,container.b,container.c]
    aux_data=container.name
    return flat_contents,aux_data

def unflatten_MyContainer(
        aux_data:str, flat_contents: Iterable[int]) -> MyContainer:
    return MyContainer(aux_data,*flat_contents)

jax.tree_util.register_pytree_node(MyContainer,flatten_MyContainer,unflatten_MyContainer)





class MyKeyPathContainer(MyContainer):
    pass

def flatten_with_keys_MyKeyPathContainer(container) -> tuple[Iterable[int],str]:
    flat_contents = [(jax.tree_util.GetAttrKey('a'), container.a),(jax.tree_util.GetAttrKey('b'), container.b),(jax.tree_util.GetAttrKey('c'), container.c)]
    
    aux_data=container.name
    return flat_contents,aux_data

def unflatten_MyKeyPathContainer(
        aux_data: str, flat_contents: Iterable[int]) -> MyKeyPathContainer:
    return MyKeyPathContainer(aux_data, *flat_contents)

jax.tree_util.register_pytree_with_keys(
    MyKeyPathContainer, flatten_with_keys_MyKeyPathContainer, unflatten_MyKeyPathContainer)

flattened,_=jax.tree_util.tree_flatten_with_path(MyContainer('Alice',1,2,3))
for key_path, value in flattened:
    print(f'MyContainer contianer{jax.tree_util.keystr(key_path)}: {value}')
    
flattened, _=jax.tree_util.tree_flatten_with_path(MyKeyPathContainer('Alice',1,2,3))
for key_path, value in flattened:
    print(f'MyKeyPathContainer container{jax.tree_util.keystr(key_path)}: {value}')


tt=jax.tree_util.tree_leaves([MyKeyPathContainer('Alice', 1 ,2, 3), MyKeyPathContainer('Bob', 4 ,5, 6)])